\documentclass[12pt]{extarticle}
\usepackage{phys460}

\title{PHYS460 - Exercises from Nielsen and Chuang (2016)}
\author{John Hurst}
\date{December 2023}

\begin{document}
\maketitle

% \tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\question{3.1}{(Non-computable processes in Nature) How might we recognize that a process in Nature computes a function not computable by a Turing machine?
}

If a process in Nature contains any random element, then it cannot be exactly computed by a Turing machine, because Turing machines are completely deterministic.
(It may be possible to approximate or simulate the process with a Turing machine, using pseudorandom numbers.)

If a process in Nature is continuous, then it cannot be computed by a Turing machine, because Turing machines are discrete.
(It may be possible to approximate the process to arbitrary accuracy, using rational numbers.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\question{3.2}{(Turing numbers) Show that single-tape Turing machines can each be given a number from the list 1, 2, 3, ... in such a way that the number uniquely specifies the corresponding machine.
We call this number the \textit{Turing number} of the corresponding machine.
}

Let's suppose that our machine has the minimal alphabet $\Gamma = \{0, 1, \square, \vartriangleright\}$,
and that there are $m$ states $q_1, q_2, \ldots, q_m$, besides the special states $q_s, q_h$.

With these fixed, a given Turing machine is uniquely determined by its \textit{program}, which is an ordered list of program lines:
\begin{align*}
& \langle r_1, x_1, r'_1, x'_1, s_1 \rangle \\
& \langle r_2, x_2, r'_2, x'_2, s_2 \rangle \\
& \langle r_3, x_3, r'_3, x'_3, s_3 \rangle \\
& \cdots \\
& \langle r_n, x_n, r'_n, x'_n, s_n \rangle
\end{align*}
where
\begin{align*}
r_k, r'_k & \in \{q_1, q_2, \ldots, q_m, q_s, q_h\}   && k\in\{1,2,\dots, n\}\\
x_k, x'_k & \in \{0, 1, \square, \vartriangleright\} && k\in\{1,2,\dots, n\}\\
s_k & \in \{-1, 0, 1\} && k\in\{1,2,\dots, n\}
\end{align*}
We can assign a unique number $N$ to each possible program by
\[
N = \prod_{k=1}^n p_k^{w_k}
\]
where
\begin{align*}
p_k & = k\text{th prime number}\\
w_k & = 2^{a_k} \times 3^{b_k} \times 5^{c_k} \times 7^{d_k} \times 11^{e_k} \\
a_k & = \begin{cases}i & \text{if }r_k = q_i, i\in\{1,2,\dots,m\}\\m+1 & \text{if }r_k = q_s\\m+2 & \text{if }r_k = q_h\end{cases}\\
b_k & = \begin{cases}1 & \text{if }x_k = 0\\2 & \text{if }x_k = 1\\3 & \text{if }x_k = \square\\4 & \text{if }x_k = \vartriangleright\end{cases}\\
c_k & = \begin{cases}i & \text{if }r'_k = q_i\\m+1 & \text{if }r'_k = q_s\\m+2 & \text{if }r'_k = q_h\end{cases}\\
d_k & = \begin{cases}1 & \text{if }x'_k = 0\\2 & \text{if }x'_k = 1\\3 & \text{if }x'_k = \square\\4 & \text{if }x'_k = \vartriangleright\end{cases}\\
e_k & = \begin{cases}1 & \text{if }s_k = -1\\2 & \text{if }s_k = 0\\3 & \text{if }s_k = 1\end{cases}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\question{3.3}{(Turing machine to reverse a bit string) Describe a Turing machine which takes a binary number $x$ as its input, and outputs the bits of $x$ in reverse order.
}

The hint suggests to use a multi-tape Turing machine and additional symbols.
We can do it reasonably with a single tape, with some extra symbols \texttt{X} and \texttt{Z}.

We'll describe a Turing machine that does these steps:
\begin{enumerate}
    \item Append separator \texttt{X} and terminator \texttt{Z}.
    \item Remove digit from end of input and append to output.
    \item Repeat until no more input.
    \item Remove separator \texttt{X}.
    \item Shift output to beginning of tape.
    \item Remove terminator.
\end{enumerate}

We will use these states:
\begin{itemize}
    \item \texttt{ax}: Initialise: append separator 'X' to end of input
    \item \texttt{az}: Append terminator 'Z' to end of tape
    \item \texttt{bx}: Reverse from 'Z' to 'X'
    \item \texttt{bi}: Reverse from 'X' to end of input
    \item \texttt{m0}: Move '0' from input to end of output
    \item \texttt{m1}: Move '1' from input to end of output
    \item \texttt{rx}: Remove separator 'X'
    \item \texttt{so}: Shift output
    \item \texttt{s0}: Shift '0' digit
    \item \texttt{p0}: Put shifted '0' digit
    \item \texttt{s1}: Shift '1' digit
    \item \texttt{p1}: Put shifted '1' digit
\end{itemize}

Step 1: Append separator \texttt{X} and terminator \texttt{Z}:

\begin{align*}
\langle qs, start, ax, start, +1 \rangle \\
\langle ax, 0, ax, 0, +1 \rangle \\
\langle ax, 1, ax, 1, +1 \rangle \\
\langle ax, blank, az, X, +1 \rangle \\
\langle az, 0, az, 0, +1 \rangle \\
\langle az, 1, az, 1, +1 \rangle \\
\langle az, blank, bx, Z, -1 \rangle \\
\langle bx, 0, bx, 0, -1 \rangle \\
\langle bx, 1, bx, 1, -1 \rangle \\
\langle bx, X, bi, X, -1 \rangle \\
\langle bi, blank, bi, blank, -1 \rangle
\end{align*}

Step 2: Remove digit from end of input and append to output.
Step 3: Repeat until no more input.
\begin{align*}
\langle bi, 0, m0, blank, +1 \rangle \\
\langle m0, blank, m0, blank, +1 \rangle \\
\langle m0, X, m0, X, +1 \rangle \\
\langle m0, 0, m0, 0, +1 \rangle \\
\langle m0, 1, m0, 1, +1 \rangle \\
\langle m0, Z, az, 0, +1 \rangle \\
\langle bi, 1, m1, blank, +1 \rangle \\
\langle m1, blank, m1, blank, +1 \rangle \\
\langle m1, X, m1, X, +1 \rangle \\
\langle m1, 0, m1, 0, +1 \rangle \\
\langle m1, 1, m1, 1, +1 \rangle \\
\langle m1, Z, az, 1, +1 \rangle
\end{align*}

Step 4: Remove separator 'X'.
\begin{align*}
\langle bi, start, rx, start, +1 \rangle \\
\langle rx, blank, rx, blank, +1 \rangle \\
\langle rx, X, so, blank, +1 \rangle
\end{align*}

Step 5: Shift output to beginning of tape.
\begin{align*}
\langle so, blank, so, blank, +1 \rangle \\
\langle so, 0, s0, blank, -1 \rangle \\
\langle s0, blank, s0, blank, -1 \rangle \\
\langle s0, start, p0, start, +1 \rangle \\
\langle s0, 0, p0, 0, +1 \rangle \\
\langle s0, 1, p0, 1, +1 \rangle \\
\langle p0, blank, so, 0, +1 \rangle \\
\langle so, 1, s1, blank, -1 \rangle \\
\langle s1, blank, s1, blank, -1 \rangle \\
\langle s1, start, p1, start, +1 \rangle \\
\langle s1, 0, p1, 0, +1 \rangle \\
\langle s1, 1, p1, 1, +1 \rangle \\
\langle p1, blank, so, 1, +1 \rangle
\end{align*}

Step 6: Remove terminator.
\begin{align*}
\langle so, Z, qh, blank, 0 \rangle
\end{align*}

Given the input $11000$, the machine will progress like this:
\[
\begin{array}{c c c c c c c c c c c c c l}
\vartriangleright & 1 & 1 & 0 & 0 & 0 \\
\vartriangleright & 1 & 1 & 0 & 0 & 0 & \texttt{X} \\
\vartriangleright & 1 & 1 & 0 & 0 & 0 & \texttt{X} & \texttt{Z} \\
\vartriangleright & 1 & 1 & 0 & 0 & \square  & \texttt{X} & 0 & \texttt{Z} \\
\vartriangleright & 1 & 1 & 0 & \square  & \square  & \texttt{X} & 0 & 0 & \texttt{Z} \\
\vartriangleright & 1 & 1 & \square  & \square  & \square  & \texttt{X} & 0 & 0 & 0 & \texttt{Z} \\
\vartriangleright & 1 & \square  & \square  & \square  & \square  & \texttt{X} & 0 & 0 & 0 & 1 & \texttt{Z} \\
\vartriangleright & \square  & \square  & \square  & \square  & \square  & \texttt{X} & 0 & 0 & 0 & 1 & 1 & \texttt{Z} \\
\vartriangleright & \square  & \square  & \square  & \square  & \square  & \square  & 0 & 0 & 0 & 1 & 1 & \texttt{Z} \\
\vartriangleright & 0 & \square  & \square  & \square  & \square  & \square  & \square  & 0 & 0 & 1 & 1 & \texttt{Z} \\
\vartriangleright & 0 & 0 & \square  & \square  & \square  & \square  & \square  & \square  & 0 & 1 & 1 & \texttt{Z} \\
\vartriangleright & 0 & 0 & \square  & \square  & \square  & \square  & \square  & \square  & \square  & 1 & 1 & \texttt{Z} \\
\vartriangleright & 0 & 0 & 0 & \square  & \square  & \square  & \square  & \square  & \square  & \square  & 1 & \texttt{Z} \\
\vartriangleright & 0 & 0 & 0 & 1 & \square  & \square  & \square  & \square  & \square  & \square  & \square  & \texttt{Z} \\
\vartriangleright & 0 & 0 & 0 & 1 & 1 & \square  & \square  & \square  & \square  & \square  & \square  & \texttt{Z} \\
\vartriangleright & 0 & 0 & 0 & 1 & 1 \\
\end{array}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\question{3.6}{(Universality of \boolnand) Show that the \boolnand gate can be used to simulate the \booland, \boolxor and \boolnot gates,
provided wires, ancilla bits and \boolfanout are available.
}

De Morgan's laws are:

\begin{align*}
\boolnot (x \booland y) & = \boolnot x \boolor \boolnot y \\
\boolnot (x \boolor y) & = \boolnot x \booland \boolnot y
\end{align*}

We can obtain \boolnot from \boolnand:
\begin{align*}
x \boolnand x & = \boolnot (x \booland x) \\
& = \boolnot x
\end{align*}

Now we can get \boolor from \boolnand and \boolnot:
\begin{align*}
(\boolnot x) \boolnand (\boolnot y) & = \boolnot ((\boolnot x) \booland (\boolnot y)) \\
& = \boolnot (\boolnot (x \boolor y)) \\
& = x \boolor y
\end{align*}

\booland can be defined from from \boolnot and \boolor:
\begin{align*}
\boolnot((\boolnot x) \boolor (\boolnot y)) & = \boolnot(\boolnot x) \booland \boolnot(\boolnot y) \\
 & = x \booland y
\end{align*}

Finally, \boolxor can be defined from \booland and \boolor:
\begin{align*}
(x \booland \boolnot y) \boolor (\boolnot x \booland y) & = (x \booland y) \boolor (\boolnot x \booland \boolnot y) \\
& = x \boolxor y
\end{align*}


% \printbibliography
% \addcontentsline{toc}{section}{References}

\end{document}
